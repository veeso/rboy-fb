use std::time::{Duration, Instant};

use crate::input::config::{KeyConfig, RepeatConfig};
use crate::input::gpio::{Gpio, GpioValue};

/// Configuration for an individual key binding
pub struct KeyState<GPIO>
where
    GPIO: Gpio,
{
    pub gpio: GPIO,
    pub keycode: crate::KeypadKey,
    pub debounce: Duration,
    pub repeat: Option<RepeatConfig>,
    pub state: State,
}

impl<G> KeyState<G>
where
    G: Gpio,
{
    /// Handle an event for the gpio and update the state accordingly.
    ///
    /// Returns the [`OutEvent`] generated by this state change.
    pub fn handle_gpio_value(&mut self, value: GpioValue) -> OutEvent {
        let (new_state, out_event) =
            self.state
                .handle_gpio_value(value, self.repeat.as_ref(), self.debounce);
        if out_event != OutEvent::None {
            debug!(
                "Key {keycode:?} state change: {old_state:?} -> {new_state:?}, event: {out_event:?}",
                keycode = self.keycode,
                old_state = self.state,
            );
        }
        self.state = new_state;

        out_event
    }
}

impl<GPIO> From<KeyConfig<GPIO>> for KeyState<GPIO>
where
    GPIO: Gpio,
{
    fn from(config: KeyConfig<GPIO>) -> Self {
        KeyState {
            gpio: config.gpio,
            keycode: config.keycode,
            debounce: config.debounce,
            repeat: config.repeat,
            state: State::Unknown,
        }
    }
}

/// Output event generated by a key state change
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OutEvent {
    Press,
    Release,
    Repeat,
    None,
}

/// Describes the current state of a key
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum State {
    /// The key state is unknown (initial state)
    Unknown,
    /// The key is currently released
    Released { since: Instant },
    /// The key is currently pressed
    Pressed { since: Instant },
    /// The key is being repeated
    Repeating { last_repeat: Instant },
}

impl State {
    /// Handle an event and return the new state and the [`OutEvent`]
    ///
    /// This function works as a state machine transition handler.
    pub fn handle_gpio_value(
        self,
        value: GpioValue,
        repeat: Option<&RepeatConfig>,
        debounce: Duration,
    ) -> (Self, OutEvent) {
        match value {
            GpioValue::Enabled => self.handle_gpio_enabled(repeat, debounce),
            GpioValue::Disabled => self.handle_gpio_disabled(debounce),
        }
    }

    /// Handle the GPIO being in the disabled state
    fn handle_gpio_disabled(self, debounce: Duration) -> (Self, OutEvent) {
        match self {
            // if pressed, and debounced, go to released
            Self::Pressed { .. } if self.is_debounced(debounce) => (
                Self::Released {
                    since: Instant::now(),
                },
                OutEvent::Release,
            ),
            // if pressed, but not debounced, stay pressed
            Self::Pressed { .. } => (self, OutEvent::None),
            // if released, stay released
            Self::Released { .. } => (self, OutEvent::None),
            // if repeating, go to released
            Self::Repeating { .. } => (
                Self::Released {
                    since: Instant::now(),
                },
                OutEvent::Release,
            ),
            // if unknown, go to released
            Self::Unknown => (
                Self::Released {
                    since: Instant::now(),
                },
                OutEvent::None,
            ),
        }
    }

    /// Handle the GPIO being in the enabled state
    fn handle_gpio_enabled(
        self,
        repeat: Option<&RepeatConfig>,
        debounce: Duration,
    ) -> (Self, OutEvent) {
        // this matches ONLY with the enabled state. In any other case, we short-circuit to Released
        match self {
            // if released, and debounced, go to pressed
            Self::Released { .. } if self.is_debounced(debounce) => (
                Self::Pressed {
                    since: Instant::now(),
                },
                OutEvent::Press,
            ),
            // if released, but not debounced, stay released
            Self::Released { .. } => (self, OutEvent::None),
            // if pressed, go to repeating or stay pressed
            Self::Pressed { since } if repeat.is_some() => {
                let repeat = repeat.expect("can't be empty");
                // if enough time has passed, go to repeating
                if since.elapsed() >= repeat.delay {
                    (
                        Self::Repeating {
                            last_repeat: Instant::now(),
                        },
                        OutEvent::Repeat,
                    )
                } else {
                    (self, OutEvent::None)
                }
            }
            // if pressed, but no repeat configured, stay pressed
            Self::Pressed { .. } => (self, OutEvent::None),
            // if repeating, check if it's time for another repeat
            Self::Repeating { last_repeat } => {
                let repeat = repeat.expect("can't be empty");
                if last_repeat.elapsed() >= repeat.rate {
                    (
                        Self::Repeating {
                            last_repeat: Instant::now(),
                        },
                        OutEvent::Repeat,
                    )
                } else {
                    (self, OutEvent::None)
                }
            }
            // if unknown, go to pressed
            Self::Unknown => (
                Self::Pressed {
                    since: Instant::now(),
                },
                OutEvent::Press,
            ),
        }
    }

    /// Check if the current state has been stable for at least the debounce duration
    fn is_debounced(&self, debounce: Duration) -> bool {
        match self {
            Self::Pressed { since } | Self::Released { since } => since.elapsed() >= debounce,
            Self::Repeating { .. } => false, // handled within repeating logic
            Self::Unknown => false,
        }
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_should_handle_gpio_enabled_press() {
        let now = Instant::now();

        let state = State::Released {
            since: now - Duration::from_millis(200),
        };
        let (new_state, out_event) =
            state.handle_gpio_value(GpioValue::Enabled, None, Duration::from_millis(100));
        assert!(
            matches!(new_state, State::Pressed { .. }),
            "Expected state to be Pressed"
        );
        assert_eq!(out_event, OutEvent::Press);
    }

    #[test]
    fn test_should_handle_gpio_disabled_release() {
        let now = Instant::now();
        let state = State::Pressed {
            since: now - Duration::from_millis(200),
        };
        let (new_state, out_event) =
            state.handle_gpio_value(GpioValue::Disabled, None, Duration::from_millis(100));
        assert!(
            matches!(new_state, State::Released { .. }),
            "Expected state to be Released"
        );
        assert_eq!(out_event, OutEvent::Release);
    }

    #[test]
    fn test_should_handle_gpio_enabled_debounce() {
        let now = Instant::now();

        let state = State::Released {
            since: now - Duration::from_millis(50),
        };
        let (new_state, out_event) =
            state.handle_gpio_value(GpioValue::Enabled, None, Duration::from_millis(100));
        assert!(
            matches!(new_state, State::Released { .. }),
            "Expected state to remain Released"
        );
        assert_eq!(out_event, OutEvent::None);
    }

    #[test]
    fn test_should_handle_gpio_disabled_debounce() {
        let now = Instant::now();
        let state = State::Pressed {
            since: now - Duration::from_millis(50),
        };
        let (new_state, out_event) =
            state.handle_gpio_value(GpioValue::Disabled, None, Duration::from_millis(100));
        assert!(
            matches!(new_state, State::Pressed { .. }),
            "Expected state to remain Pressed"
        );
        assert_eq!(out_event, OutEvent::None);
    }

    #[test]
    fn test_should_handle_repeating() {
        let now = Instant::now();

        let state = State::Pressed {
            since: now - Duration::from_millis(200),
        };
        let repeat_config = RepeatConfig {
            delay: Duration::from_millis(100),
            rate: Duration::from_millis(50),
        };
        let (new_state, out_event) = state.handle_gpio_value(
            GpioValue::Enabled,
            Some(&repeat_config),
            Duration::from_millis(50),
        );
        assert!(
            matches!(new_state, State::Repeating { .. }),
            "Expected state to be Repeating"
        );
        assert_eq!(out_event, OutEvent::Repeat);
    }

    #[test]
    fn test_should_handle_repeating_rate() {
        let now = Instant::now();

        let state = State::Repeating {
            last_repeat: now - Duration::from_millis(60),
        };
        let repeat_config = RepeatConfig {
            delay: Duration::from_millis(100),
            rate: Duration::from_millis(50),
        };
        let (new_state, out_event) = state.handle_gpio_value(
            GpioValue::Enabled,
            Some(&repeat_config),
            Duration::from_millis(50),
        );
        assert!(
            matches!(new_state, State::Repeating { .. }),
            "Expected state to remain Repeating"
        );
        assert_eq!(out_event, OutEvent::Repeat);
    }

    #[test]
    fn test_should_not_handle_repeating_rate_too_soon() {
        let now = Instant::now();

        let state = State::Repeating {
            last_repeat: now - Duration::from_millis(30),
        };
        let repeat_config = RepeatConfig {
            delay: Duration::from_millis(100),
            rate: Duration::from_millis(50),
        };
        let (new_state, out_event) = state.handle_gpio_value(
            GpioValue::Enabled,
            Some(&repeat_config),
            Duration::from_millis(50),
        );
        assert!(
            matches!(new_state, State::Repeating { .. }),
            "Expected state to remain Repeating"
        );
        assert_eq!(out_event, OutEvent::None);
    }

    #[test]
    fn test_should_handle_unknown_to_pressed() {
        let state = State::Unknown;
        let (new_state, out_event) =
            state.handle_gpio_value(GpioValue::Enabled, None, Duration::from_millis(100));
        assert!(
            matches!(new_state, State::Pressed { .. }),
            "Expected state to be Pressed"
        );
        assert_eq!(out_event, OutEvent::Press);
    }

    #[test]
    fn test_should_handle_unknown_to_released() {
        let state = State::Unknown;
        let (new_state, out_event) =
            state.handle_gpio_value(GpioValue::Disabled, None, Duration::from_millis(100));
        assert!(
            matches!(new_state, State::Released { .. }),
            "Expected state to be Released"
        );
        assert_eq!(out_event, OutEvent::None);
    }

    #[test]
    fn test_should_tell_whether_is_debounced() {
        let now = Instant::now();

        let state = State::Pressed {
            since: now - Duration::from_millis(200),
        };
        assert!(state.is_debounced(Duration::from_millis(100)));

        let state = State::Pressed {
            since: now - Duration::from_millis(50),
        };
        assert!(!state.is_debounced(Duration::from_millis(100)));

        let state = State::Released {
            since: now - Duration::from_millis(150),
        };
        assert!(state.is_debounced(Duration::from_millis(100)));

        let state = State::Released {
            since: now - Duration::from_millis(30),
        };
        assert!(!state.is_debounced(Duration::from_millis(100)));

        let state = State::Repeating {
            last_repeat: now - Duration::from_millis(500),
        };
        assert!(!state.is_debounced(Duration::from_millis(100)));

        let state = State::Unknown;
        assert!(!state.is_debounced(Duration::from_millis(100)));
    }
}
